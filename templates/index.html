<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polar Planimeter Simulation</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <!-- MathJax configuration for proper TeX delimiters -->
    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$','$'], ['\\(','\\)']],
          displayMath: [['$$','$$'], ['\\[','\\]']]
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            background: #fff5f7;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        .container {
            margin: 20px;
            text-align: center;
            max-width: 1200px;
            width: 100%;
        }
        h1 {
            color: #d53f8c;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(213, 63, 140, 0.1);
        }
        .canvas-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin: 20px 0;
            background: white;
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(213, 63, 140, 0.1);
        }
        .simulation-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        .main-simulation {
            flex: 2;
        }
        .component-details {
            flex: 1;
            background: #fdf2f7;
            padding: 15px;
            border-radius: 10px;
            box-shadow: inset 0 2px 4px rgba(213, 63, 140, 0.05);
        }
        .component-view {
            width: 100%;
            height: 150px;
            margin-bottom: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .component-title {
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
            margin: 10px 0;
        }
        .component-description {
            font-size: 12px;
            color: #34495e;
            margin-bottom: 15px;
            line-height: 1.4;
        }
        canvas {
            border: 2px solid #fbb6ce;
            background: white;
        }
        canvas.grid {
            background-image:
                linear-gradient(to right, #fde8ef 1px, transparent 1px),
                linear-gradient(to bottom, #fde8ef 1px, transparent 1px);
            background-size: 50px 50px;
        }
        .controls {
            margin: 30px 0;
            display: flex;
            gap: 15px;
            justify-content: center;
        }
        button {
            padding: 12px 25px;
            font-size: 16px;
            cursor: pointer;
            background: #ed64a6;
            color: white;
            border: none;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(213, 63, 140, 0.2);
        }
        button:hover {
            background: #d53f8c;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(213, 63, 140, 0.3);
        }
        button:disabled {
            background: #fbb6ce;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .info {
            margin: 30px 0;
            font-size: 20px;
            color: #2c3e50;
            font-weight: 500;
        }
        .canvas-label {
            font-size: 18px;
            margin-bottom: 10px;
            color: #2c3e50;
            font-weight: 500;
        }
        .variables {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: nowrap;
        }
        .variable {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(213, 63, 140, 0.1);
            min-width: 150px;
            flex: 1;
            transition: transform 0.3s ease;
            position: relative;
            font-size: 0.9em;
            border: 1px solid #fbb6ce;
        }
        .variable:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(213, 63, 140, 0.15);
            border-color: #ed64a6;
        }
        .variable:hover .tooltip {
            display: block;
        }
        .tooltip {
            display: none;
            position: absolute;
            background: rgba(213, 63, 140, 0.95);
            color: white;
            padding: 10px;
            border-radius: 6px;
            font-size: 14px;
            width: 200px;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 10px;
            z-index: 100;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .tooltip::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-width: 0 6px 6px 6px;
            border-style: solid;
            border-color: transparent transparent rgba(213, 63, 140, 0.95) transparent;
        }
        .variable-name {
            font-weight: 600;
            color: #d53f8c;
            margin-bottom: 5px;
            font-size: 0.9em;
            white-space: nowrap;
        }
        .variable-value {
            color: #ed64a6;
            font-size: 1.1em;
            font-weight: 500;
        }
        .charts {
            display: flex;
            gap: 20px;
            margin: 30px 0;
            justify-content: center;
        }
        .chart-container {
            flex: 1;
            max-width: 600px;
        }
        .chart {
            width: 500px;
            height: 350px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
        }
        .planimeter-component {
            position: absolute;
            pointer-events: none;
        }
        .component-label {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            color: #2c3e50;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            pointer-events: none;
        }
        .mechanical-part {
            position: absolute;
            pointer-events: none;
            border: 2px solid #7f8c8d;
            background: #ecf0f1;
        }
        .chart-description {
            text-align: left;
            margin: 10px 20px;
            color: #34495e;
            font-size: 14px;
            line-height: 1.5;
        }
        .math-explanation {
            margin: 40px auto;
            padding: 30px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-width: 800px;
            text-align: left;
        }
        .math-explanation h2 {
            color: #2c3e50;
            margin-bottom: 20px;
        }
        .math-explanation p {
            color: #34495e;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .value-indicator {
            position: absolute;
            background: rgba(255, 255, 255, 0.9);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            color: #2c3e50;
            pointer-events: none;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .progress-bar-container {
            width: 100%;
            height: 8px;
            background: #fde8ef;
            overflow: hidden;
            position: relative;
            margin: 0;
            box-shadow: inset 0 2px 4px rgba(213, 63, 140, 0.1);
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #ed64a6, #d53f8c);
            transition: width 0.3s ease;
        }
        .mechanical-linkage {
            position: absolute;
            pointer-events: none;
            border: 2px solid #95a5a6;
            background: #ecf0f1;
            transform-origin: 0 50%;
        }
        .joint {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #7f8c8d;
            border: 2px solid #95a5a6;
            pointer-events: none;
        }
        .measurement-line {
            position: absolute;
            border-top: 2px dashed #3498db;
            pointer-events: none;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(213, 63, 140, 0.1);
        }
        .control-group label {
            color: #2c3e50;
            font-weight: 500;
        }
        .control-group input {
            width: 80px;
            padding: 5px;
            border: 1px solid #fbb6ce;
            border-radius: 4px;
            color: #2c3e50;
        }
        .control-group input:focus {
            outline: none;
            border-color: #ed64a6;
            box-shadow: 0 0 0 2px rgba(237, 100, 166, 0.2);
        }
        .control-group .tooltip {
            font-size: 12px;
            color: #666;
            font-style: italic;
        }
        .formula-display {
            background: white;
            padding: 20px;
            margin: 20px auto;
            border-radius: 10px;
            box-shadow: 0 2px 4px rgba(213, 63, 140, 0.1);
            max-width: 800px;
        }
        .formula-display h3 {
            color: #d53f8c;
            margin-bottom: 15px;
            text-align: center;
        }
        .formula-row {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .formula {
            font-size: 1.2em;
            font-weight: 500;
            color: #2c3e50;
            font-family: 'Times New Roman', serif;
        }
        .formula-where {
            color: #666;
            font-style: italic;
        }
        .formula-terms {
            list-style: none;
            padding-left: 20px;
            color: #34495e;
        }
        .formula-terms li {
            margin: 5px 0;
        }
        .formula-result {
            margin-top: 10px;
            padding: 10px;
            background: #fdf2f7;
            border-radius: 5px;
            color: #2c3e50;
            font-family: 'Times New Roman', serif;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Polar Planimeter Simulation</h1>
        
        <div class="canvas-container">
            <div class="grid-info" style="font-size:14px;color:#555;margin-bottom:8px;">Grid: 1 unit per square</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar" style="width: 0%"></div>
            </div>
            <div class="simulation-container">
                <div class="main-simulation">
                    <div>
                        <div class="canvas-label">Draw your shape here:</div>
                        <canvas id="drawingCanvas" class="grid" width="800" height="400"></canvas>
                    </div>
                    <div>
                        <div class="canvas-label">Planimeter visualization:</div>
                        <canvas id="calculationCanvas" class="grid" width="800" height="400"></canvas>
                    </div>
                </div>
                <div class="component-details">
                    <div class="component-view">
                        <canvas id="wheelDetailCanvas" width="300" height="150"></canvas>
                        <div class="component-title">Measuring Wheel Detail</div>
                        <div class="component-description">
                            The measuring wheel both rolls and slides. The net rotation is proportional to the area.
                            Red arrow shows rolling direction, blue shows sliding.
                        </div>
                    </div>
                    <div class="component-view">
                        <canvas id="tracerDetailCanvas" width="300" height="150"></canvas>
                        <div class="component-title">Tracer Movement Detail</div>
                        <div class="component-description">
                            The tracer point follows the curve boundary. The arm angle and wheel position
                            continuously adjust based on this movement.
                        </div>
                    </div>
                    <div class="component-view">
                        <canvas id="poleDetailCanvas" width="300" height="150"></canvas>
                        <div class="component-title">Pole Mechanism Detail</div>
                        <div class="component-description">
                            The fixed pole serves as the pivot point. The arm's rotation around this point
                            helps convert linear motion into area measurement.
                        </div>
                    </div>
                    <div class="component-view" style="height: 350px;">
                        <canvas id="dialCanvas" width="300" height="350"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="scaleFactor">Planimeter Constant:</label>
                <input type="number" id="scaleFactor" value="0.1684" readonly>
                <span class="tooltip">Fixed constant for this planimeter design</span>
            </div>
            <button id="clearBtn">Clear Canvas</button>
            <button id="startBtn">Start Calculation</button>
            <button id="stopBtn" disabled>Stop Calculation</button>
            <button id="circleBtn">Create Circle (r=2)</button>
            <button id="squareBtn">Create Square (s=3)</button>
        </div>
        
        <div class="variables">
            <div class="variable">
                <div class="variable-name">Tracer Position</div>
                <div class="variable-value" id="tracerPosition">(0, 0)</div>
                <div class="tooltip">The current position of the tracing point that follows the curve's boundary</div>
            </div>
            <div class="variable">
                <div class="variable-name">Pole Position</div>
                <div class="variable-value" id="polePosition">(0, 0)</div>
                <div class="tooltip">The fixed pivot point around which the planimeter arm rotates</div>
            </div>
            <div class="variable">
                <div class="variable-name">Wheel Rotation</div>
                <div class="variable-value" id="wheelRotation">0.00 rad</div>
                <div class="tooltip">The current angle of the measuring wheel, which integrates the area</div>
            </div>
            <div class="variable">
                <div class="variable-name">Outline Length</div>
                <div class="variable-value" id="wheelDistance">0.0000</div>
                <div class="tooltip">Total length of the curve's outline (in grid units)</div>
            </div>
            <div class="variable">
                <div class="variable-name">Planimeter Area</div>
                <div class="variable-value" id="currentArea">0.0000</div>
                <div class="tooltip">The area measured by the planimeter (in grid square units)</div>
            </div>
            <div class="variable">
                <div class="variable-name">Actual Area</div>
                <div class="variable-value" id="groundTruthArea">0.0000</div>
                <div class="tooltip">The actual area of the shape calculated using the shoelace formula</div>
            </div>
        </div>
        
        <div class="formula-display">
            <h3>Area Calculation</h3>
            <div class="formula-row">
                <span class="formula">Area = k × R × L</span>
                <span class="formula-where">where:</span>
                <ul class="formula-terms">
                    <li><strong>k</strong> = 0.1684 (planimeter constant)</li>
                    <li><strong>R</strong> = <span id="formulaRotation">0.00</span> rad (wheel rotation)</li>
                    <li><strong>L</strong> = <span id="formulaLength">3.00</span> units (arm length)</li>
                </ul>
                <div class="formula-result">
                    Area = 0.08038585209 × <span id="formulaRotationValue">0.00</span> × <span id="formulaLengthValue">3.00</span> = <span id="formulaResult">0.0000</span> square units
                </div>
            </div>
        </div>
        
        <div class="charts">
            <div class="chart-container">
                <div id="areaChart" class="chart"></div>
                <div class="chart-description">
                    This graph shows the accumulation of area as the tracer point moves along the boundary.
                    The final height represents the total area enclosed by the curve.
                </div>
            </div>
            <div class="chart-container">
                <div id="wheelChart" class="chart"></div>
                <div class="chart-description">
                    This graph shows the measuring wheel's rotation angle over time.
                    The net rotation of the wheel is proportional to the enclosed area.
                </div>
            </div>
            <div class="chart-container">
                <div id="velocityChart" class="chart"></div>
                <div class="chart-description">
                    This graph shows the instantaneous velocity of the measuring wheel.
                    The velocity indicates how quickly the wheel is rotating at each point in time.
                </div>
            </div>
        </div>
        

        
        <div class="info">
            Final Area: <span id="finalArea">0</span> square units
        </div>
    </div>
    
    <div class="math-explanation">
        <h2>How Does a Planimeter Work?</h2>
        <p>The polar planimeter is a purely mechanical instrument that calculates area by converting the boundary of a shape into a rotation of its measuring wheel. As you guide the tracer around the perimeter, every motion—rolling and sliding—contributes to the total rotation.</p>
        <p>When the tracer moves, it pulls on the main arm; the arm transmits force through the parallelogram linkage to hold the wheel in contact. The measuring wheel rolls along two dimensions: rolling integrates the component of motion tangential to its rotation, while sliding accounts for the perpendicular motion. Together, these movements encode the integral of <em>x dy − y dx</em> around the curve.</p>
        <p style="text-align: center;">
            \[ 
            \mathrm{Area} = \oint_C x\,dy - y\,dx = L \int_0^T \omega(t)\,dt 
            \]
        </p>
        <p>Here:</p>
        <ul>
            <li><strong>\(C\)</strong> is the closed path you trace.</li>
            <li><strong>\(L\)</strong> is the effective arm length from the pivot to the wheel axle.</li>
            <li><strong>\(\omega(t)\)</strong> is the instantaneous angular velocity of the measuring wheel.</li>
            <li><strong>\(T\)</strong> is the total time (or path length) to complete the circuit.</li>
        </ul>
        <p>Mechanically, the planimeter is elegant: it implements Green's theorem \( \oint_C x\,dy - y\,dx = \text{area} \) through a combination of linkages and a measuring wheel, performing the integral automatically.</p>
        <h3>Step-by-Step Operation</h3>
        <ol>
            <li><strong>Tracing the Curve</strong>: You drag the tracer point precisely along the shape's boundary.</li>
            <li><strong>Main Arm Motion</strong>: The tracer pulls the main arm, pivoting around the fixed pole.</li>
            <li><strong>Parallelogram Linkage</strong>: The two-bar linkage maintains the measuring wheel at a constant distance and orientation, converting linear tracer motion into wheel displacement.</li>
            <li><strong>Wheel Movement</strong>: The wheel rolls on the surface (measuring tangential motion) and slides (perpendicular motion); the combination encodes the path integral.</li>
            <li><strong>Integration</strong>: The wheel's net rotation, accumulated over the circuit, equals the enclosed area divided by the arm length \(L\).</li>
        </ol>
        <h3>Mechanical Components Explained</h3>
        <ul>
            <li><strong>Fixed Pole:</strong> A sturdy pivot anchored in place. All motion originates here.</li>
            <li><strong>Main Arm (gray):</strong> The bar between the pole and tracer. Its length changes as you trace the shape.</li>
            <li><strong>Parallelogram Bars:</strong> Two rigid rods of equal fixed length (green and dashed red in the animation). They never change length and maintain the constant offset of the wheel.</li>
            <li><strong>Tracer Point (red dot):</strong> A small pin that follows the shape's edge, converting the boundary into mechanical motion.</li>
            <li><strong>Measuring Wheel:</strong> A friction wheel that both rolls and slides, turning motion into angular rotation proportional to area.</li>
        </ul>
    </div>
    
    <script>
        // Constants
        const PLANIMETER_CONSTANT = 0.1684;
        const WHEEL_RADIUS = 10; // pixels
        const WHEEL_CIRCUMFERENCE = 50; // 1 grid unit = 50 pixels
        let scaleFactor = 1.0;
        
        // Get the canvases and their contexts
        const drawingCanvas = document.getElementById('drawingCanvas');
        const calculationCanvas = document.getElementById('calculationCanvas');
        const wheelDetailCanvas = document.getElementById('wheelDetailCanvas');
        const tracerDetailCanvas = document.getElementById('tracerDetailCanvas');
        const poleDetailCanvas = document.getElementById('poleDetailCanvas');
        
        const drawingCtx = drawingCanvas.getContext('2d');
        const calculationCtx = calculationCanvas.getContext('2d');
        const wheelDetailCtx = wheelDetailCanvas.getContext('2d');
        const tracerDetailCtx = tracerDetailCanvas.getContext('2d');
        const poleDetailCtx = poleDetailCanvas.getContext('2d');
        
        // Drawing state
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let points = [];
        let calculationActive = false;
        let currentIndex = 0;
        let calculationInterval;
        
        // Planimeter state
        let polePosition = { x: 400, y: 200 }; // Fixed pole position
        let tracerPosition = { x: 0, y: 0 };
        let wheelRotation = 0;
        let wheelDistance = 0;
        let cumulativeRotation = 0;
        let lastPathAngle = 0;
        
        // Chart data
        let areaData = [];
        let wheelData = [];
        let timeData = [];
        let velocityData = [];
        
        // Drawing functions
        function startDrawing(e) {
            if (calculationActive) return;
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
            points = [{ x: lastX, y: lastY }];
        }
        
        function draw(e) {
            if (!isDrawing || calculationActive) return;
            
            drawingCtx.beginPath();
            drawingCtx.moveTo(lastX, lastY);
            drawingCtx.lineTo(e.offsetX, e.offsetY);
            drawingCtx.strokeStyle = '#2c3e50';
            drawingCtx.lineWidth = 3;
            drawingCtx.stroke();
            
            points.push({ x: e.offsetX, y: e.offsetY });
            [lastX, lastY] = [e.offsetX, e.offsetY];
        }
        
        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            if (points.length > 2) {
                // Close the shape
                drawingCtx.beginPath();
                drawingCtx.moveTo(points[0].x, points[0].y);
                drawingCtx.lineTo(points[points.length - 1].x, points[points.length - 1].y);
                drawingCtx.stroke();
                points.push(points[0]);
                
                // Calculate and display ground truth area
                const groundTruthArea = calculateAreaUpTo(points.length - 1) / 2500; // Convert to grid units
                document.getElementById('groundTruthArea').textContent = groundTruthArea.toFixed(4);
            }
        }
        
        // Calculation functions
        function startCalculation() {
            if (points.length < 3) return;
            calculationActive = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            
            currentIndex = 0;
            areaData = [];
            wheelData = [];
            timeData = [];
            velocityData = [];
            wheelRotation = 0;
            wheelDistance = 0;
            cumulativeRotation = 0;
            lastPathAngle = 0;
            
            // Initialize charts
            initializeCharts();
            
            calculationInterval = setInterval(updateCalculation, 50);
        }
        
        function stopCalculation() {
            calculationActive = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            clearInterval(calculationInterval);
            
            // Calculate final area using wheel rotation and scale factor
            scaleFactor = PLANIMETER_CONSTANT;
            const finalArea = Math.abs(cumulativeRotation) * scaleFactor * 3; // Using arm length of 3
            document.getElementById('currentArea').textContent = finalArea.toFixed(4);
            document.getElementById('finalArea').textContent = finalArea.toFixed(4);
        }
        
        function updateCalculation() {
            if (currentIndex >= points.length - 1) {
                stopCalculation();
                return;
            }
            
            const currentPoint = points[currentIndex];
            const nextPoint = points[currentIndex + 1];
            
            // Calculate vectors and distances
            const dx = nextPoint.x - currentPoint.x;
            const dy = nextPoint.y - currentPoint.y;
            const ds = Math.sqrt(dx * dx + dy * dy);
            
            // Calculate perpendicular distance from pole to path segment
            const midX = (currentPoint.x + nextPoint.x) / 2 - polePosition.x;
            const midY = (currentPoint.y + nextPoint.y) / 2 - polePosition.y;
            const pathDirX = dx / ds;
            const pathDirY = dy / ds;
            
            // Calculate perpendicular vector to path
            const perpX = -pathDirY;
            const perpY = pathDirX;
            
            // Calculate perpendicular distance (h) from pole to path
            const h = Math.abs(midX * perpX + midY * perpY);
            
            // Calculate wheel rotation based on perpendicular distance and path length
            if (currentIndex > 0 && ds > 0) {
                const crossProduct = dx * midY - dy * midX;
                const sign = -Math.sign(crossProduct);
                
                // For a wheel with circumference of 1 grid unit:
                // - One full rotation (2π radians) = 1 grid unit of circumference
                // - Need to convert from pixels to grid units (divide by 50)
                const rotationChange = sign * (h * ds) / (50 * 50);
                cumulativeRotation += rotationChange;
            }
            
            // Update positions more smoothly using interpolation
            const progress = (currentIndex % 1) * animationSpeed;
            tracerPosition = {
                x: currentPoint.x + (nextPoint.x - currentPoint.x) * progress,
                y: currentPoint.y + (nextPoint.y - currentPoint.y) * progress
            };
            
            // Calculate wheel position using parallelogram linkage
            const apx = tracerPosition.x - polePosition.x;
            const apy = tracerPosition.y - polePosition.y;
            const armLen = Math.sqrt(apx*apx + apy*apy) || 1;
            const ux = apx / armLen;
            const uy = apy / armLen;
            const vx = -uy;
            const vy = ux;
            const h_offset = wheelOffset;
            const link1X = tracerPosition.x + vx * h_offset;
            const link1Y = tracerPosition.y + vy * h_offset;
            const link2X = polePosition.x + vx * h_offset;
            const link2Y = polePosition.y + vy * h_offset;
            const mainWheelX = link2X;
            const mainWheelY = link2Y;
            
            // Update wheel rotation display
            wheelRotation = cumulativeRotation;
            document.getElementById('wheelRotation').textContent = `${cumulativeRotation.toFixed(2)} rad`;
            
            // Calculate area based on wheel rotation and scale factor
            // Area = k × |R| × L where k is the planimeter constant, R is rotation, and L is arm length
            scaleFactor = PLANIMETER_CONSTANT;
            const planimeterArea = Math.abs(cumulativeRotation) * scaleFactor * 3; // Using arm length of 3
            document.getElementById('currentArea').textContent = planimeterArea.toFixed(4);
            
            // Update wheel distance
            wheelDistance += ds / 50;
            document.getElementById('wheelDistance').textContent = wheelDistance.toFixed(4);
            
            // Draw the main visualization
            calculationCtx.clearRect(0, 0, calculationCanvas.width, calculationCanvas.height);

            // Draw the shape outline
            calculationCtx.beginPath();
            calculationCtx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                calculationCtx.lineTo(points[i].x, points[i].y);
            }
            calculationCtx.strokeStyle = '#2c3e50';
            calculationCtx.lineWidth = 3;
            calculationCtx.stroke();
            
            // Draw mechanical base plate under pole for clarity
            calculationCtx.beginPath();
            calculationCtx.arc(polePosition.x, polePosition.y, 30, 0, Math.PI * 2);
            calculationCtx.fillStyle = '#cccccc';
            calculationCtx.fill();
            calculationCtx.strokeStyle = '#888888';
            calculationCtx.lineWidth = 2;
            calculationCtx.stroke();

            // Draw main arm from pole to tracer (mechanical beam)
            calculationCtx.beginPath();
            calculationCtx.moveTo(polePosition.x, polePosition.y);
            calculationCtx.lineTo(tracerPosition.x, tracerPosition.y);
            calculationCtx.lineWidth = 8;
            calculationCtx.strokeStyle = '#777777';
            calculationCtx.stroke();
            
            // Draw parallelogram linkage bars (two colors)
            calculationCtx.lineWidth = 8;
            calculationCtx.strokeStyle = '#777777';
            calculationCtx.beginPath();
            calculationCtx.moveTo(link1X, link1Y);
            calculationCtx.lineTo(link2X, link2Y);
            calculationCtx.stroke();
            
            // Green bar: constant-length linkage from tracer to link1
            calculationCtx.lineWidth = 6;
            calculationCtx.strokeStyle = '#2ecc71';
            calculationCtx.beginPath();
            calculationCtx.moveTo(tracerPosition.x, tracerPosition.y);
            calculationCtx.lineTo(link1X, link1Y);
            calculationCtx.stroke();
            
            // Red dashed bar: constant-length linkage from pole to link2
            calculationCtx.save();
            calculationCtx.setLineDash([30, 15]);
            calculationCtx.lineWidth = 8;
            calculationCtx.strokeStyle = '#e74c3c';
            calculationCtx.beginPath();
            calculationCtx.moveTo(polePosition.x, polePosition.y);
            calculationCtx.lineTo(link2X, link2Y);
            calculationCtx.stroke();
            calculationCtx.restore();
            
            // Draw joints at the four corners
            [[polePosition.x, polePosition.y],[tracerPosition.x, tracerPosition.y],[link1X,link1Y],[link2X,link2Y]].forEach(([x,y])=>{
                calculationCtx.beginPath();
                calculationCtx.arc(x,y,6,0,Math.PI*2);
                calculationCtx.fillStyle='#7f8c8d';
                calculationCtx.fill();
                calculationCtx.lineWidth=2;
                calculationCtx.strokeStyle='#95a5a6';
                calculationCtx.stroke();
            });
            
            // Draw measurement line
            calculationCtx.beginPath();
            calculationCtx.moveTo(tracerPosition.x, tracerPosition.y);
            calculationCtx.lineTo(mainWheelX, mainWheelY);
            calculationCtx.setLineDash([5, 5]);
            calculationCtx.strokeStyle = '#3498db';
            calculationCtx.lineWidth = 2;
            calculationCtx.stroke();
            calculationCtx.setLineDash([]);
            
            // Draw wheel as seen from above
            calculationCtx.save();
            calculationCtx.translate(mainWheelX, mainWheelY);
            
            // Draw wheel as ellipse with fixed radius
            const wheelHeight = WHEEL_RADIUS * 0.4; // Perspective scaling
            calculationCtx.beginPath();
            calculationCtx.ellipse(0, 0, WHEEL_RADIUS, wheelHeight, 0, 0, Math.PI * 2);
            calculationCtx.fillStyle = '#bdc3c7';
            calculationCtx.fill();
            calculationCtx.strokeStyle = '#7f8c8d';
            calculationCtx.lineWidth = 2;
            calculationCtx.stroke();
            
            // Draw wheel markings to show rotation
            const numMarkings = 8;
            for(let i = 0; i < numMarkings; i++) {
                const angle = (i / numMarkings) * Math.PI * 2 + wheelRotation;
                const x1 = Math.cos(angle) * WHEEL_RADIUS;
                const y1 = Math.sin(angle) * wheelHeight;
                const x2 = Math.cos(angle) * (WHEEL_RADIUS - 2);
                const y2 = Math.sin(angle) * (wheelHeight - 1);
                
                calculationCtx.beginPath();
                calculationCtx.moveTo(x1, y1);
                calculationCtx.lineTo(x2, y2);
                calculationCtx.strokeStyle = '#34495e';
                calculationCtx.lineWidth = 2;
                calculationCtx.stroke();
            }
            
            // Draw axle line
            calculationCtx.beginPath();
            calculationCtx.moveTo(-WHEEL_RADIUS, 0);
            calculationCtx.lineTo(WHEEL_RADIUS, 0);
            calculationCtx.strokeStyle = '#7f8c8d';
            calculationCtx.lineWidth = 3;
            calculationCtx.stroke();
            
            calculationCtx.restore();
            
            // Update variables display
            document.getElementById('tracerPosition').textContent = 
                `(${(tracerPosition.x/50).toFixed(2)}, ${(tracerPosition.y/50).toFixed(2)})`;
            document.getElementById('polePosition').textContent = 
                `(${(polePosition.x/50).toFixed(2)}, ${(polePosition.y/50).toFixed(2)})`;
            
            // Update charts data and redraw
            areaData.push(planimeterArea);
            wheelData.push(cumulativeRotation);
            velocityData.push(ds > 0 ? h / wheelOffset : 0);
            updateCharts();

            // Update progress bar
            const progressPercentage = (currentIndex / (points.length - 1)) * 100;
            document.getElementById('progressBar').style.width = `${progressPercentage}%`;
            
            // Update detail views
            updateWheelDetail();
            updateTracerDetail();
            updatePoleDetail();
            updateFormulaDisplay();
            updateDial();

            currentIndex++;
        }
        
        // Shoelace formula implementation (Green's Theorem):
        function calculateAreaUpTo(index) {
            // This computes half the sum of (x_i * y_{i+1} - x_{i+1} * y_i) for all edges up to 'index'
            let area = 0;
            for (let i = 0; i < index; i++) {
                const j = (i + 1) % points.length;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            return Math.abs(area) / 2;
        }
        
        function initializeCharts() {
            // Area chart
            Plotly.newPlot('areaChart', [{
                y: areaData,
                type: 'scatter',
                mode: 'lines',
                name: 'Area',
                line: {
                    color: '#ed64a6',
                    width: 3
                }
            }], {
                title: 'Area Over Time',
                xaxis: { title: 'Time' },
                yaxis: { title: 'Area (grid units²)' },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#fff5f7',
                font: {
                    family: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
                    size: 14,
                    color: '#d53f8c'
                }
            });
            
            // Wheel rotation chart
            Plotly.newPlot('wheelChart', [{
                y: wheelData,
                type: 'scatter',
                mode: 'lines',
                name: 'Wheel Rotation',
                line: {
                    color: '#d53f8c',
                    width: 3,
                    shape: 'spline'
                }
            }], {
                title: 'Wheel Rotation Over Time',
                xaxis: { title: 'Time' },
                yaxis: { 
                    title: 'Rotation (radians)',
                    autorange: true
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#fff5f7',
                font: {
                    family: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
                    size: 14,
                    color: '#d53f8c'
                }
            });

            // Velocity chart
            Plotly.newPlot('velocityChart', [{
                y: velocityData,
                type: 'scatter',
                mode: 'lines',
                name: 'Wheel Velocity',
                line: {
                    color: '#ed64a6',
                    width: 3,
                    shape: 'spline',
                    smoothing: 1.3  // Added smoothing
                }
            }], {
                title: 'Wheel Velocity Over Time',
                xaxis: { title: 'Time' },
                yaxis: { 
                    title: 'Angular Velocity (radians/s)',
                    range: [-5, 5]
                },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: '#fff5f7',
                font: {
                    family: 'Segoe UI, Tahoma, Geneva, Verdana, sans-serif',
                    size: 14,
                    color: '#d53f8c'
                }
            });
        }
        
        function updateCharts() {
            // Update area chart
            Plotly.update('areaChart', {
                y: [areaData]
            });
            
            // Update wheel chart
            Plotly.update('wheelChart', {
                y: [wheelData]
            });

            // Update velocity chart
            Plotly.update('velocityChart', {
                y: [velocityData]
            });
        }
        
        function updateWheelDetail() {
            wheelDetailCtx.clearRect(0, 0, wheelDetailCanvas.width, wheelDetailCanvas.height);
            
            const centerX = wheelDetailCanvas.width / 2;
            const centerY = wheelDetailCanvas.height / 2;
            
            // Draw degree markings
            wheelDetailCtx.save();
            wheelDetailCtx.translate(centerX, centerY);
            for(let i = 0; i < 12; i++) {
                const angle = i * 30;
                const rad = angle * Math.PI / 180;
                
                // Draw longer marks at cardinal points
                const isCardinal = i % 3 === 0;
                const markLength = isCardinal ? 10 : 5;
                
                wheelDetailCtx.beginPath();
                wheelDetailCtx.moveTo(Math.cos(rad) * 45, Math.sin(rad) * 45);
                wheelDetailCtx.lineTo(Math.cos(rad) * (45 + markLength), Math.sin(rad) * (45 + markLength));
                wheelDetailCtx.strokeStyle = '#7f8c8d';
                wheelDetailCtx.lineWidth = isCardinal ? 2 : 1;
                wheelDetailCtx.stroke();
                
                if (isCardinal) {
                    wheelDetailCtx.save();
                    wheelDetailCtx.translate(Math.cos(rad) * 60, Math.sin(rad) * 60);
                    wheelDetailCtx.rotate(rad + Math.PI/2);
                    wheelDetailCtx.fillStyle = '#34495e';
                    wheelDetailCtx.font = '11px Arial';
                    wheelDetailCtx.fillText(angle + '°', -10, 4);
                    wheelDetailCtx.restore();
                }
            }
            wheelDetailCtx.restore();
            
            // Rest of wheel detail drawing...
            
            // Add current rotation indicator
            const rotationDegrees = (wheelRotation * 180 / Math.PI) % 360;
            wheelDetailCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            wheelDetailCtx.fillRect(10, 10, 80, 20);
            wheelDetailCtx.fillStyle = '#2c3e50';
            wheelDetailCtx.font = '12px Arial';
            wheelDetailCtx.fillText(`${rotationDegrees.toFixed(1)}°`, 15, 24);
        }

        function updateTracerDetail() {
            tracerDetailCtx.clearRect(0, 0, tracerDetailCanvas.width, tracerDetailCanvas.height);
            
            const centerX = tracerDetailCanvas.width / 2;
            const centerY = tracerDetailCanvas.height / 2;
            
            // Draw path segment
            tracerDetailCtx.beginPath();
            tracerDetailCtx.moveTo(centerX - 60, centerY);
            tracerDetailCtx.quadraticCurveTo(centerX, centerY - 40, centerX + 60, centerY);
            tracerDetailCtx.strokeStyle = '#2c3e50';
            tracerDetailCtx.lineWidth = 2;
            tracerDetailCtx.stroke();
            
            // Draw tracer point
            const tracerX = centerX + Math.cos(wheelRotation * 2) * 30;
            const tracerY = centerY + Math.sin(wheelRotation) * 20;
            
            tracerDetailCtx.beginPath();
            tracerDetailCtx.arc(tracerX, tracerY, 15, 0, Math.PI * 2);
            tracerDetailCtx.fillStyle = '#e74c3c';
            tracerDetailCtx.fill();
            tracerDetailCtx.strokeStyle = '#c0392b';
            tracerDetailCtx.lineWidth = 3;
            tracerDetailCtx.stroke();
            
            // Draw crosshair
            tracerDetailCtx.beginPath();
            tracerDetailCtx.moveTo(tracerX - 12, tracerY);
            tracerDetailCtx.lineTo(tracerX + 12, tracerY);
            tracerDetailCtx.moveTo(tracerX, tracerY - 12);
            tracerDetailCtx.lineTo(tracerX, tracerY + 12);
            tracerDetailCtx.strokeStyle = '#c0392b';
            tracerDetailCtx.lineWidth = 1;
            tracerDetailCtx.stroke();
            
            // Draw direction arrow
            const arrowAngle = Math.atan2(
                points[currentIndex + 1]?.y - points[currentIndex]?.y,
                points[currentIndex + 1]?.x - points[currentIndex]?.x
            ) || 0;
            
            tracerDetailCtx.save();
            tracerDetailCtx.translate(tracerX, tracerY);
            tracerDetailCtx.rotate(arrowAngle);
            
            tracerDetailCtx.beginPath();
            tracerDetailCtx.moveTo(20, 0);
            tracerDetailCtx.lineTo(35, 0);
            tracerDetailCtx.strokeStyle = '#27ae60';
            tracerDetailCtx.lineWidth = 3;
            tracerDetailCtx.stroke();
            
            tracerDetailCtx.beginPath();
            tracerDetailCtx.moveTo(35, 0);
            tracerDetailCtx.lineTo(35 - 10, -5);
            tracerDetailCtx.lineTo(35 - 10, 5);
            tracerDetailCtx.fillStyle = '#27ae60';
            tracerDetailCtx.fill();
            
            tracerDetailCtx.restore();
            
            // Add position indicators
            const relativeX = (tracerX - centerX).toFixed(1);
            const relativeY = (centerY - tracerY).toFixed(1);
            
            tracerDetailCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            tracerDetailCtx.fillRect(10, 10, 100, 40);
            tracerDetailCtx.fillStyle = '#2c3e50';
            tracerDetailCtx.font = '12px Arial';
            tracerDetailCtx.fillText(`X: ${relativeX}`, 15, 24);
            tracerDetailCtx.fillText(`Y: ${relativeY}`, 15, 44);
        }

        function updatePoleDetail() {
            poleDetailCtx.clearRect(0, 0, poleDetailCanvas.width, poleDetailCanvas.height);
            
            const centerX = poleDetailCanvas.width / 2;
            const centerY = poleDetailCanvas.height / 2;
            
            // Draw base plate
            poleDetailCtx.beginPath();
            poleDetailCtx.arc(centerX, centerY, 35, 0, Math.PI * 2);
            poleDetailCtx.fillStyle = '#bdc3c7';
            poleDetailCtx.fill();
            poleDetailCtx.strokeStyle = '#95a5a6';
            poleDetailCtx.lineWidth = 3;
            poleDetailCtx.stroke();
            
            // Draw pole
            poleDetailCtx.beginPath();
            poleDetailCtx.arc(centerX, centerY, 20, 0, Math.PI * 2);
            poleDetailCtx.fillStyle = '#95a5a6';
            poleDetailCtx.fill();
            poleDetailCtx.strokeStyle = '#7f8c8d';
            poleDetailCtx.lineWidth = 3;
            poleDetailCtx.stroke();
            
            // Draw arm rotation indicator
            const armAngle = Math.atan2(
                tracerPosition.y - polePosition.y,
                tracerPosition.x - polePosition.x
            );
            
            poleDetailCtx.save();
            poleDetailCtx.translate(centerX, centerY);
            poleDetailCtx.rotate(armAngle);
            
            // Draw arm
            poleDetailCtx.beginPath();
            poleDetailCtx.moveTo(0, 0);
            poleDetailCtx.lineTo(60, 0);
            poleDetailCtx.strokeStyle = '#95a5a6';
            poleDetailCtx.lineWidth = 8;
            poleDetailCtx.stroke();
            
            // Draw rotation arrow
            poleDetailCtx.beginPath();
            poleDetailCtx.arc(0, 0, 45, -Math.PI/4, Math.PI/4);
            poleDetailCtx.strokeStyle = '#27ae60';
            poleDetailCtx.lineWidth = 2;
            poleDetailCtx.stroke();
            
            // Arrow head
            poleDetailCtx.beginPath();
            poleDetailCtx.moveTo(45 * Math.cos(Math.PI/4), 45 * Math.sin(Math.PI/4));
            poleDetailCtx.lineTo(45 * Math.cos(Math.PI/4) - 8, 45 * Math.sin(Math.PI/4) - 8);
            poleDetailCtx.lineTo(45 * Math.cos(Math.PI/4) + 5, 45 * Math.sin(Math.PI/4) - 10);
            poleDetailCtx.fillStyle = '#27ae60';
            poleDetailCtx.fill();
            
            poleDetailCtx.restore();
            
            // Add angle indicator
            const angleDegrees = (armAngle * 180 / Math.PI) % 360;
            poleDetailCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            poleDetailCtx.fillRect(10, 10, 80, 20);
            poleDetailCtx.fillStyle = '#2c3e50';
            poleDetailCtx.font = '12px Arial';
            poleDetailCtx.fillText(`${angleDegrees.toFixed(1)}°`, 15, 24);
            
            // Draw angle arc with degree markings
            poleDetailCtx.save();
            poleDetailCtx.translate(centerX, centerY);
            
            // Draw degree markings every 30 degrees
            for(let i = -3; i <= 3; i++) {
                const angle = i * 30;
                const rad = angle * Math.PI / 180;
                
                poleDetailCtx.beginPath();
                poleDetailCtx.moveTo(Math.cos(rad) * 45, Math.sin(rad) * 45);
                poleDetailCtx.lineTo(Math.cos(rad) * 50, Math.sin(rad) * 50);
                poleDetailCtx.strokeStyle = '#95a5a6';
                poleDetailCtx.lineWidth = 1;
                poleDetailCtx.stroke();
                
                // Add degree numbers
                if (i !== 0) {
                    poleDetailCtx.save();
                    poleDetailCtx.translate(Math.cos(rad) * 60, Math.sin(rad) * 60);
                    poleDetailCtx.rotate(rad + Math.PI/2);
                    poleDetailCtx.fillStyle = '#34495e';
                    poleDetailCtx.font = '11px Arial';
                    poleDetailCtx.fillText(Math.abs(angle) + '°', -10, 4);
                    poleDetailCtx.restore();
                }
            }
            poleDetailCtx.restore();
        }
        
        // Event listeners
        drawingCanvas.addEventListener('mousedown', startDrawing);
        drawingCanvas.addEventListener('mousemove', draw);
        drawingCanvas.addEventListener('mouseup', stopDrawing);
        drawingCanvas.addEventListener('mouseout', stopDrawing);
        
        document.getElementById('clearBtn').addEventListener('click', () => {
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            calculationCtx.clearRect(0, 0, calculationCanvas.width, calculationCanvas.height);
            points = [];
            document.getElementById('tracerPosition').textContent = '(0, 0)';
            document.getElementById('polePosition').textContent = '(0, 0)';
            document.getElementById('wheelRotation').textContent = '0.00 rad';
            document.getElementById('wheelDistance').textContent = '0.0000';
            document.getElementById('currentArea').textContent = '0.0000';
            document.getElementById('finalArea').textContent = '0.0000';
            Plotly.purge('areaChart');
            Plotly.purge('wheelChart');
        });
        
        document.getElementById('startBtn').addEventListener('click', startCalculation);
        document.getElementById('stopBtn').addEventListener('click', stopCalculation);
        
        let animationSpeed = 0.5; // Controls animation speed (lower = slower)
        let wheelOffset = 150; // Distance between tracer and wheel (increased for clearer linkage)

        // Function to generate points for a circle
        function generateCirclePoints(radius, centerX, centerY, numPoints = 100) {
            const points = [];
            for (let i = 0; i <= numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                points.push({ x, y });
            }
            return points;
        }

        // Function to generate points for a square with smooth animation
        function generateSquarePoints(side, centerX, centerY, numPointsPerSide = 25) {
            const halfSide = side / 2;
            const points = [];
            
            // Generate points for each side with proper spacing
            // Top side
            for (let i = 0; i <= numPointsPerSide; i++) {
                const x = centerX - halfSide + (side * i / numPointsPerSide);
                const y = centerY - halfSide;
                points.push({ x, y });
            }
            
            // Right side
            for (let i = 1; i <= numPointsPerSide; i++) {
                const x = centerX + halfSide;
                const y = centerY - halfSide + (side * i / numPointsPerSide);
                points.push({ x, y });
            }
            
            // Bottom side
            for (let i = 1; i <= numPointsPerSide; i++) {
                const x = centerX + halfSide - (side * i / numPointsPerSide);
                const y = centerY + halfSide;
                points.push({ x, y });
            }
            
            // Left side
            for (let i = 1; i <= numPointsPerSide; i++) {
                const x = centerX - halfSide;
                const y = centerY + halfSide - (side * i / numPointsPerSide);
                points.push({ x, y });
            }
            
            return points;
        }

        // Function to draw points with animation
        function drawPointsWithAnimation(newPoints) {
            // Clear existing points and canvas
            points = [];
            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            
            let currentIndex = 0;
            const drawInterval = setInterval(() => {
                if (currentIndex >= newPoints.length) {
                    clearInterval(drawInterval);
                    return;
                }
                
                const point = newPoints[currentIndex];
                points.push(point);
                
                if (currentIndex > 0) {
                    const prevPoint = newPoints[currentIndex - 1];
                    drawingCtx.beginPath();
                    drawingCtx.moveTo(prevPoint.x, prevPoint.y);
                    drawingCtx.lineTo(point.x, point.y);
                    drawingCtx.strokeStyle = '#2c3e50';
                    drawingCtx.lineWidth = 3;
                    drawingCtx.stroke();
                }
                
                currentIndex++;
            }, 20); // Adjust timing as needed
        }

        // Event listeners for new buttons
        document.getElementById('circleBtn').addEventListener('click', () => {
            const centerX = drawingCanvas.width / 2;
            const centerY = drawingCanvas.height / 2;
            const radius = 100; // 2 units * 50 pixels per unit
            const circlePoints = generateCirclePoints(radius, centerX, centerY);
            drawPointsWithAnimation(circlePoints);
            
            // Calculate and display ground truth area for circle
            const groundTruthArea = Math.PI * 4; // πr² = π(2)² = 4π
            document.getElementById('groundTruthArea').textContent = groundTruthArea.toFixed(4);
        });

        document.getElementById('squareBtn').addEventListener('click', () => {
            const centerX = drawingCanvas.width / 2;
            const centerY = drawingCanvas.height / 2;
            const side = 150; // 3 units * 50 pixels per unit
            const squarePoints = generateSquarePoints(side, centerX, centerY);
            drawPointsWithAnimation(squarePoints);
            
            // Calculate and display ground truth area for square
            const groundTruthArea = 9; // 3² = 9
            document.getElementById('groundTruthArea').textContent = groundTruthArea.toFixed(4);
        });

        // Add this function to update the formula display
        function updateFormulaDisplay() {
            const rotation = cumulativeRotation;
            const k = PLANIMETER_CONSTANT; // Planimeter constant
            const L = 3.0; // Fixed arm length
            
            // Calculate the exact same way as planimeterArea
            const area = Math.abs(rotation) * k * L;
            
            document.getElementById('formulaRotation').textContent = rotation.toFixed(2);
            document.getElementById('formulaLength').textContent = L.toFixed(2);
            document.getElementById('formulaRotationValue').textContent = Math.abs(rotation).toFixed(2);
            document.getElementById('formulaLengthValue').textContent = L.toFixed(2);
            document.getElementById('formulaResult').textContent = area.toFixed(4);
        }

        function updateDial() {
            const dialCanvas = document.getElementById('dialCanvas');
            const dialCtx = dialCanvas.getContext('2d');
            const centerX = dialCanvas.width / 2;
            const centerY = dialCanvas.height / 2 - 25; // Move everything up a bit
            const outerRadius = Math.min(centerX, centerY) - 20;
            const innerRadius = outerRadius * 0.6;
            
            // Clear canvas
            dialCtx.clearRect(0, 0, dialCanvas.width, dialCanvas.height);
            
            // Draw outer ring (angle dial)
            dialCtx.beginPath();
            dialCtx.arc(centerX, centerY, outerRadius, 0, Math.PI * 2);
            dialCtx.strokeStyle = '#7f8c8d';
            dialCtx.lineWidth = 3;
            dialCtx.stroke();
            
            // Draw inner ring (rotation counter)
            dialCtx.beginPath();
            dialCtx.arc(centerX, centerY, innerRadius, 0, Math.PI * 2);
            dialCtx.strokeStyle = '#7f8c8d';
            dialCtx.lineWidth = 3;
            dialCtx.stroke();
            
            // Draw degree markings
            for(let i = 0; i < 360; i += 30) {
                const angle = (i - 90) * Math.PI / 180;
                const isMajor = i % 90 === 0;
                const markLength = isMajor ? 15 : 10;
                
                dialCtx.beginPath();
                dialCtx.moveTo(
                    centerX + Math.cos(angle) * (outerRadius - markLength),
                    centerY + Math.sin(angle) * (outerRadius - markLength)
                );
                dialCtx.lineTo(
                    centerX + Math.cos(angle) * outerRadius,
                    centerY + Math.sin(angle) * outerRadius
                );
                dialCtx.strokeStyle = isMajor ? '#2c3e50' : '#95a5a6';
                dialCtx.lineWidth = isMajor ? 2 : 1;
                dialCtx.stroke();
                
                if(isMajor) {
                    dialCtx.save();
                    dialCtx.translate(
                        centerX + Math.cos(angle) * (outerRadius - 30),
                        centerY + Math.sin(angle) * (outerRadius - 30)
                    );
                    dialCtx.rotate(angle + Math.PI/2);
                    dialCtx.fillStyle = '#2c3e50';
                    dialCtx.font = '14px Arial';
                    dialCtx.textAlign = 'center';
                    dialCtx.fillText(i.toString(), 0, 0);
                    dialCtx.restore();
                }
            }
            
            // Draw rotation count markers
            for(let i = 0; i <= 40; i += 5) {  // Changed from 10 to 40, marks every 5
                const angle = (i * 9 - 90) * Math.PI / 180;  // 360/40 = 9 degrees per unit
                const isMajor = i % 10 === 0;  // Major marks every 10 units
                const markLength = isMajor ? 12 : 8;
                
                dialCtx.beginPath();
                dialCtx.moveTo(
                    centerX + Math.cos(angle) * innerRadius,
                    centerY + Math.sin(angle) * innerRadius
                );
                dialCtx.lineTo(
                    centerX + Math.cos(angle) * (innerRadius - markLength),
                    centerY + Math.sin(angle) * (innerRadius - markLength)
                );
                dialCtx.strokeStyle = isMajor ? '#2c3e50' : '#7f8c8d';
                dialCtx.lineWidth = isMajor ? 2 : 1;
                dialCtx.stroke();
                
                if(isMajor) {
                    dialCtx.save();
                    dialCtx.translate(
                        centerX + Math.cos(angle) * (innerRadius - 25),
                        centerY + Math.sin(angle) * (innerRadius - 25)
                    );
                    dialCtx.rotate(angle + Math.PI/2);
                    dialCtx.fillStyle = '#2c3e50';
                    dialCtx.font = '12px Arial';
                    dialCtx.fillText(i.toString(), 0, 0);
                    dialCtx.restore();
                }
            }
            
            // Calculate rotations
            const absRotation = Math.abs(cumulativeRotation);
            const fullRotations = absRotation / (2 * Math.PI);
            const remainingAngle = ((absRotation % (2 * Math.PI)) * 180 / Math.PI);
            
            // Draw outer needle (angle)
            const outerAngle = (remainingAngle - 90) * Math.PI / 180;
            dialCtx.beginPath();
            dialCtx.moveTo(centerX, centerY);
            dialCtx.lineTo(
                centerX + Math.cos(outerAngle) * (outerRadius - 20),
                centerY + Math.sin(outerAngle) * (outerRadius - 20)
            );
            dialCtx.strokeStyle = '#e74c3c';
            dialCtx.lineWidth = 2;
            dialCtx.stroke();
            
            // Draw inner needle (rotations)
            const innerAngle = (fullRotations * 9 - 90) * Math.PI / 180;  // 360/40 = 9 degrees per unit
            dialCtx.beginPath();
            dialCtx.moveTo(centerX, centerY);
            dialCtx.lineTo(
                centerX + Math.cos(innerAngle) * (innerRadius - 20),
                centerY + Math.sin(innerAngle) * (innerRadius - 20)
            );
            dialCtx.strokeStyle = '#3498db';
            dialCtx.lineWidth = 2;
            dialCtx.stroke();
            
            // Draw center cap
            dialCtx.beginPath();
            dialCtx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            dialCtx.fillStyle = '#2c3e50';
            dialCtx.fill();
            
            // Display current value - show the exact decimal value for rotations
            dialCtx.fillStyle = '#2c3e50';
            dialCtx.font = '14px Arial';
            dialCtx.textAlign = 'center';
            dialCtx.fillText(`${fullRotations.toFixed(2)} rotations = ${Math.abs(cumulativeRotation).toFixed(2)} rad`, centerX, centerY + outerRadius + 50);
        }
    </script>
</body>
</html> 